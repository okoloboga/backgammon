# Техническое задание: Серверная логика игры "Длинные нарды" для Telegram Mini Apps

## 1. Общие сведения

### 1.1 Описание игры
Длинные нарды (нард) - настольная игра для двух игроков на доске из 24 позиций (пунктов). Каждый игрок имеет 15 шашек. Цель игры - провести все свои шашки в дом и снять их с доски быстрее противника.

### 1.2 Технический стек
- Backend: NestJS + Colyseus
- Платформа: Telegram Mini Apps
- Количество игроков: 2

## 2. Игровое поле и начальная расстановка

### 2.1 Структура доски
```
Доска состоит из 24 пунктов, пронумерованных от 1 до 24:
- Пункты 1-6: дом белых
- Пункты 7-12: двор белых  
- Пункты 13-18: двор черных
- Пункты 19-24: дом черных

Визуализация нумерации:
13 14 15 16 17 18    19 20 21 22 23 24
12 11 10  9  8  7     6  5  4  3  2  1
```

### 2.2 Начальная позиция
```javascript
const INITIAL_POSITION = {
  white: {
    24: 15  // все 15 белых шашек на пункте 24
  },
  black: {
    1: 15   // все 15 черных шашек на пункте 1
  }
}
```

### 2.3 Направление движения
- Белые: движутся от пункта 24 к пункту 1 (по убыванию)
- Черные: движутся от пункта 1 к пункту 24 (по возрастанию)

## 3. Игровая механика

### 3.1 Состояния игры
```typescript
enum GameState {
  WAITING_FOR_PLAYER = 'waiting_for_player',
  PLAYING = 'playing',
  FINISHED = 'finished'
}
```

### 3.2 Броски костей
```typescript
interface DiceRoll {
  dice1: number;  // 1-6
  dice2: number;  // 1-6
}

// При дубле (dice1 === dice2) игрок получает 4 хода с этим значением.
// Например, при броске 3-3, игрок может сделать четыре хода на 3.
```

## 4. Логика ходов и валидации (Сервер)

### 4.1 Архитектура валидации
В отличие от простой пошаговой валидации, сервер использует **упреждающую генерацию всех возможных последовательностей ходов**.

1.  После броска костей сервер рекурсивно вычисляет **все возможные полные последовательности** ходов, которые игрок может совершить.
2.  Эти последовательности учитывают все правила игры:
    *   Запрет на ход в занятый противником пункт.
    *   Обязательное использование максимального количества костей.
    *   **Приоритет большего хода:** Если из двух костей можно сыграть только одной (но не обеими), игрок обязан использовать большую кость, если ею возможен ход.
    *   **Завершение игры:** Алгоритм корректно обрабатывает выигрышный ход (сброс последней фишки), даже если у игрока остались неиспользованные кости.
    *   Правила снятия с головы в начале игры.
    *   Правила снятия шашек с доски (bearing off).
3.  Сгенерированный список валидных последовательностей ходов сохраняется в `state.possibleMoves`.
4.  Клиент получает этот список и использует его для отображения подсвеченных ходов, не производя собственной валидации.

### 4.2 Обработка ситуации "Нет ходов"
Если после броска костей сервер определяет, что список возможных последовательностей ходов пуст (игрок заблокирован), ход **автоматически** завершается, и право хода передается сопернику. Это предотвращает "зависание" игры.

### 4.3 Правила снятия шашек (Bearing Off)
- Снятие разрешено только тогда, когда **все 15 шашек** игрока находятся в его доме.
- **Для белых (дом 1-6):**
    - Можно снимать шашки с пунктов 1-6.
    - Если значение кости точно соответствует номеру пункта, шашка снимается (например, с пункта 5 костью 5).
    - Если значение кости больше номера самого дальнего пункта с шашкой, можно снять шашку с этого самого дальнего пункта.
- **Для черных (дом 19-24):**
    - Аналогично, но для пунктов 19-24.
- Сервер генерирует ходы со специальным пунктом назначения `'off'` (например, `from: 5, to: 'off'`), которые клиент затем использует для отображения возможности снятия шашки.

## 5. Структуры данных (Colyseus Schema)

Структуры данных реализованы с помощью `@colyseus/schema` для автоматической синхронизации с клиентом.

```typescript
import { Schema, type, MapSchema, ArraySchema } from '@colyseus/schema';

// Описывает шашки на одном пункте (треугольнике)
export class Point extends Schema {
  @type('string') player: string; // 'white' или 'black'
  @type('number') checkers: number; // Количество шашек
}

// Основная схема состояния игры
export class GameState extends Schema {
  @type({ map: Point })
  board = new MapSchema<Point>();

  @type({ map: 'number' })
  bar = new MapSchema<number>({ white: 0, black: 0 });

  @type({ map: 'number' })
  off = new MapSchema<number>({ white: 0, black: 0 });

  @type('string')
  currentPlayer: string;

  @type(['number'])
  dice = new ArraySchema<number>();

  @type('string')
  winner: string | null = null;

  // Массив ВСЕХ возможных последовательностей ходов.
  // Каждый элемент - строка, представляющая полную последовательность.
  // Пример: ["24-20,20-18", "24-22,22-18"]
  @type(['string'])
  possibleMoves = new ArraySchema<string>();

  @type({ map: 'string' })
  players = new MapSchema<string>(); // e.g., { "sessionId1": "white" }
  
  // ... другие поля, такие как playerProfiles, turnCount и т.д.
}
```

## 6. API (Colyseus)

### 6.1 Команды от клиента
Сервер слушает следующие сообщения от клиента:

`onMessage("rollDice", (client) => { ... })`
- Инициирует бросок костей для текущего игрока.
- Запускает на сервере генерацию `possibleMoves`.
- Если ходов нет, автоматически передает ход сопернику.

`onMessage("move", (client, message: { from: number | 'bar'; to: number | 'off' }) => { ... })`
- Получает **один** шаг хода от клиента (например, с 24 на 20).
- Сервер находит этот шаг в одной из валидных последовательностей в `possibleMoves`.
- Применяет ход, обновляет состояние (`board`, `dice`).
- Пересчитывает `possibleMoves` на основе оставшихся костей.
- Если после этого шага больше нет возможных ходов, завершает ход.

### 6.2 События для клиента
Основное состояние синхронизируется через `room.onStateChange`. Однако, для ключевых событий конца игры сервер отправляет клиентам прямые сообщения:

`onMessage("game_over", (message: { result: 'win' | 'lose', message: string }) => { ... })`
- Отправляется обоим игрокам по нормальному завершению игры (когда один из игроков сбросил все фишки).
- `result`: 'win' для победителя, 'lose' для проигравшего.
- `message`: Текстовое сообщение с результатом (например, `WIN 100 TON.` или `LOST 100 TON.`).

`onMessage("opponent_left", (message: { message: string }) => { ... })`
- Отправляется оставшемуся игроку, если его соперник покинул игру.

Помимо этого, клиент, как и прежде, реагирует на изменения в `GameState` через `onStateChange`.

## 7. Алгоритм генерации ходов (обзор)

Сервер использует рекурсивный алгоритм для поиска всех валидных последовательностей ходов.

1.  **`calculatePossibleMoves()`**: Основная функция, которая запускает процесс и применяет правила принуждения (использовать все кости, играть больший ход).
2.  **`findMoveSequences(board, dice, player, ...)`**: Рекурсивная функция.
    - В начале рекурсии проверяет, не убраны ли уже все фишки игрока с доски. Если да, то это выигрышная позиция, и она считается валидным концом последовательности ходов.
    - Для каждой кости она находит все возможные одиночные ходы (`findAllSingleMoves`).
    - Для каждого найденного хода она:
        - Создает виртуальную доску с примененным ходом.
        - Рекурсивно вызывает сама себя с оставшимися костями.
        - Собирает и возвращает полные последовательности ходов.
3.  **`findAllSingleMoves(...)`**: Находит все возможные одиночные ходы для одной кости с текущей позиции, включая ходы с бара и снятие шашек (bearing off). Эта функция также содержит логику для "правила головы".

Этот подход гарантирует, что клиент всегда получает полный и точный список всех легальных действий, что исключает десинхронизацию и зависание игры.

